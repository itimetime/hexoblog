---
title: 【算法】快速排序算法、【数学问题】1000瓶酒找1毒酒
date: 2020-04-09 01:35:40
tags: 
categories:  Algorithm
---

### 【算法】快速排序算法

#### 算法讲解

**这些形象的小图片给我们最直观的印象**

方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。

{% asset_img 1.jpg  %}



<!--more-->
首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（**请自己想一想为什么**）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。

{% asset_img 2.jpg  %}

{% asset_img 3.jpg  %}
现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：

6  1  2  5 9 3  4  7 10  8

{% asset_img 4.jpg  %}

{% asset_img 5.jpg  %}

到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：

6  1  2 5  4 3  9 7 10  8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：

3 1 2  5  4  6 9 7  10  8

{% asset_img 6.jpg  %}

{% asset_img 7.jpg  %}

{% asset_img 8.jpg  %}

到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧

如果你模拟的没有错，调整完毕之后的序列的顺序应该是：

2  1  3 5  4

OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：


1  2  3 4  5  6 9  7  10  8

对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下

1  2  3 4  5  6  7  8 9  10

到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。

{% asset_img 9.jpg  %}

 

 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。**因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)**

#### 算法实现

算法讲解部分为数组最左边为基准，算法实现部分为最右边为基准。其遵循以下逻辑：

- 如基准为数组最左边，则从数组最右边查询比基准小的数。

- 如基准为数组最右边，则从数组最左边查询比基准大的数。

##### go语言 

go的语言特性，决定其函数只能传递指针类型的数组，且必须设定数组长度。

- 不传指针的话，其排序修改位置并不会在原数组上改变。
- 传递切片，其切片指针类型不支持索引。

```go
package main

import "fmt"


func patition(arr *[5]int, left,right int)  {
   if right <= left{
      return
   }
   low := left
   high := right
   base := arr[right]
   for ;left < right;{
      for arr[left] <= base && right > left{
         left ++
      }
      for arr[right] >= base && right > left{
         right --
      }
      if left < right {
         temp := arr[left]
         arr[left] = arr[right]
         arr[right] = temp
      }

   temp := arr[left]
   arr[left] = arr[high]
   arr[high] = temp
   fmt.Println(arr)
   patition(arr,low,left - 1)
   patition(arr,left + 1,high)
   }
}


func main()  {
   arr := [5]int{1,23,3,4896,4}
   left := 0
   right := len(arr) - 1
   patition(&arr,left,right)
   fmt.Println(arr)
}
```

##### Python

```python
#!usr/bin/env python
# -*- coding:utf-8 _*-
"""
@version: v1.0
@author:Colin
@file: 快速排序2.py
@time: 2020/4/8/11:35
"""


class Solution():
    def quick_sort(self, res):
        left = len(res) - 1
        right = 0
        ret = self.partition(right, left, res)
        return ret

    def partition(self, left, right, res):
        if left >= right:
            return res
        low = left
        high = right
        base = res[right]
        right = right
        while (left < right):
            while (left < right and res[left] <= base):
                left += 1
            while (left < right and res[right] >= base):
                right -= 1
            if left < right:
                res[left], res[right] = res[right], res[left]
        res[left], res[high] = res[high], res[left]
        self.partition(low, left - 1, res)
        self.partition(left + 1, high, res)
        return res
```

### 【数学问题】1000瓶酒找1毒酒

*问题：其中一瓶有毒，一旦吃了，都会在一周后发作，现在我们用小老鼠做实验，要在1周后找出那桶毒酒，问最少需要多少只老鼠？*

解答：10只就够了。10只老鼠按从左到右的顺序一字排好，每桶酒也编上号1到1000，并把编号转换成二进制形式（也就是只有0和1的二进制，但是为了方便，每个二进制都写满10位，不来够十位数的前面添0补满（比如1100110就写成0001100110），数位和老鼠的位置一一对应，把酒给相应位置上是1的老鼠喝（每一桶都要喝）。最后按死掉的老鼠是哪几只，然后排成二进制，再自转成十进制就是第几桶酒。比如：第70桶酒，70转换成二进制就是0001000110，那么就给第四、八、九只老鼠喝。如果最后死掉第三、七、八只老鼠，那么就是0010001100，换成十进制就是140，即140桶酒有毒。理论上这10只老鼠可以检测1024桶酒。



#### 参考链接

[快速排序算法](https://www.cnblogs.com/CBDoctor/p/4077574.html)

[百度知道](https://zhidao.baidu.com/question/348862780.html)
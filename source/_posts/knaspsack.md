---
title: 【算法】01背包问题
date: 2020-03-29 20:57:51
category:  Algorithm
tags:  Algorithm
---

#### <i class="fa fa-quora" aria-hidden="true"></i> 题目
有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？eg：number＝5，capacity＝20

| i（物品编号） | 1    | 2    | 3    | 4    | 5    |
| ------------- | ---- | ---- | ---- | ---- | ---- |
| w（体积）     | 2    | 3    | 4    | 5    | 9    |
| v （价值）    | 3    | 4    | 5    | 8    | 11   |

####  <i class="fa fa-yelp" aria-hidden="true"></i> 解释

##### 总体思路

根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。
<!--more-->
##### 动态规划的原理

动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。

最优性原理是动态规划的基础，最优性原理是指“多阶段决策过程的最优决策序列具有这样的性质：不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略”。

##### 背包问题的解决过程

在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。

*1、建立模型，即求max(V1X1+V2X2+…+VnXn)；

*2、寻找约束条件，W1X1+W2X2+…+WnXn

*3、寻找递推关系式，面对当前商品有两种可能性：*

- 包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；
- 还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。
递归分析过程：
{% asset_img QQ图片20200329215446.png   递归过程 %}
动态规划过程：
{% asset_img QQ图片20200329215430.png 动态规划 %}

#### <i class="fa fa-check-square-o" aria-hidden="true"></i> 代码实现

```
#!usr/bin/env python
# -*- coding:utf-8 _*-
"""
@version: v1.0
@author:Colin
@file: 01背包问题.py
@time: 3/21/2020/12:24 AM
"""
N = 6
W = 21
w = [0, 2, 3, 4, 5, 9]
v = [0, 3, 4, 5, 8, 10]
res = [[0 for x in range(W)] for j in range(N)]


def knaspsack():
    for i in range(1, N):
        for j in range(1, W):
            if w[i] > j:
                res[i][j] = res[i - 1][j]
            else:
                value1 = res[i - 1][j - w[i]] + v[i]
                value2 = res[i - 1][j]
                if value1 > value2:
                    res[i][j] = value1
                else:
                    res[i][j] = value2

    print(res)
knaspsack()
print(res[5][20])
```


